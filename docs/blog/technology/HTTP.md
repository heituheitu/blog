# HTTP协议

![](https://pic1.zhimg.com/v2-292eb0ba56a62cf2b198b0251b78b8cc.jpg?source=57bbeac9)

## HTTP

### 父级

 TCP/IP 协议簇。HTTP 属于它内部的一个子集（http/3之前）

### TCP/IP

#### TCP/IP 协议簇分层

| 层级                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 应用层&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | 应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议簇内预存了各类通用的应用服务。比如，FTP（File Transfer Protocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。HTTP 协议也处于该层。 |
| 传输层                                                       | 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission Control Protocol，传输控制协议）和 UDP（User Data Protocol，用户数据报协议）。 |
| 网络层                                                       | 网络层用来处理在网络上流动的数据包。                         |
| 链路层                                                       | 用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分。 |

利用 TCP/IP 协议簇进行网络通信时，会通过分层顺序与对方进行通 信。发送端从应用层往下走，接收端则从链路层往上走。

发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该 层所属的首部信息。反之，接收端在层与层传输数据时，每经过一层 时会把对应的首部消去。 这种把数据信息包装起来的做法称为封装（encapsulate）

####  TCP和HTTP的区别

TCP连接和HTTP请求是两个不同的概念。
TCP连接是网络通信中的一个基本概念，它是在两个设备之间建立的一个通信通道。TCP连接的建立、数据传输和关闭都是通过TCP协议来完成的。
HTTP请求则是在TCP连接上发送的一个具体的消息，它包含了请求的方法（如GET、POST等）、请求的URL、请求的头部信息和请求的主体信息。HTTP请求是通过HTTP协议来发送的。
TCP连接是在网络层面上进行的，而HTTP请求是在应用层面上进行的。

### 协议（protocol）

不同的硬件、操作系统之间的通信，所有的这一切都需要一种规则。而我们就把这种规则称为协议。

与 HTTP 关系密切的协议 : IP、TCP 和DNS

1. 如果要保证各种数据包准确传送到对方那里，需要满足各类条件。其中两个重要的条件是 IP 地址和 MAC地址。

   - IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC地址基本上不会更改
   - IP 间的通信依赖 MAC 地址。在网络上，通信的双方在同一局域网（LAN）内的情况是很少的，通常是经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备的 MAC地址来搜索下一个中转目标。这时，会采用 ARP 协议（AddressResolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。

2. 按层次分，TCP 位于传输层，提供可靠的字节流服务

   - 所谓的字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。

   - 为了准确无误地将数据送达目标处，TCP 协议采用了三次握手（three-way handshaking）策略。

     #### 三次握手

     ```python
     Client            Server
       |                  |
       |---- SYN ---->    | (1. Client sends SYN)
       |                  |
       |<---- SYN-ACK ----| (2. Server sends SYN-ACK)
       |                  |
       |---- ACK ---->    | (3. Client sends ACK)
       |                  |
     握手过程中使用了 TCP 的标志（flag） —— SYN（synchronize） 和ACK（acknowledgement）。
     1.发送端首先发送一个带 SYN 标志的数据包给对方。包含一个（ISN）初始序列号，用于保证数据顺序。
     2.接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示接收到SYN段，并准备好接收数据。
     3.最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。
     若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。
     ```

   - Why

     为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

     比如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。

     假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。

     #### 四次挥手

     ```python
     Client            Server
       |                  |
       |---- FIN ---->    | (1. Client sends FIN)
       |                  |
       |<---- ACK ----    | (2. Server sends ACK)
       |                  |
       |                  |
       |<---- FIN ----    | (3. Server sends FIN)
       |                  |
       |---- ACK ---->    | (4. Client sends ACK)
       |                  |
     第一步：客户端发送一个FIN报文给服务器，表示客户端不再发送数据，进入FIN-WAIT-1状态。
     第二步：服务器接收到FIN报文后，发送一个ACK报文确认收到，进入CLOSE-WAIT状态。客户端接收到ACK报文后进入FIN-WAIT-2状态。
     第三步：服务器发送一个FIN报文给客户端，表示服务器不再发送数据，进入LAST-ACK状态。
     第四步：客户端接收到FIN报文后，发送一个ACK报文确认收到，进入TIME-WAIT状态。服务器接收到ACK报文后进入CLOSED状态，连接完全关闭
     ```

     Why

     TCP是全双工模式，四次挥手确保了双方都明确对方已经关闭了连接，避免了数据丢失和未完成的传输。这种机制提供了可靠的连接终止方法，是TCP协议中保障数据传输完整性的关键步骤之一。

3. DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的协议。它提供域名到 IP 地址之间的解析服务。

   - 人容易理解域名，计算机容易理解数字ip
   - DNS 服务应运而生。DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务

URI 和 URL：URI（统一资源标识符）,URL（Uniform Resource Locator，统一资源定位符），URL是URI的一个子集

### HTTP 是一种不保存状态，即无状态（stateless）协议。

1. 随着 Web 的不断发展，因无状态而导致业务处理变得棘手的情况增多了。比如，用户登录到一家购物网站，即使他跳转到该站的其他页面后，也需要能继续保持登录状态。针对这个实例，网站为了能够掌握是谁送出的请求，需要保存用户的状态。
   HTTP/1.1 虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了 Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管理状态了。
2. 告知服务器意图的 HTTP 方法
3. GET ：获取资源;POST：传输实体主体;PUT：传输文件;HEAD：获得报文首部;DELETE：删除文件;CONNECT：要求用隧道协议连接代理

### HTTP管线化

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求，同时并行发送多个请求。

### 使用 Cookie 的状态管理

1. 假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。
2. Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态，Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。
3. 服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

### HTTP 报文

1. HTTP 请求报文

```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate, br
Connection: keep-alive
Upgrade-Insecure-Requests: 1
```

**解析:**

1. **请求行：**

   - ```
     GET /index.html HTTP/1.1
     ```

     - `GET`：请求方法
     - `/index.html`：请求的 URI
     - `HTTP/1.1`：HTTP 版本

2. **首部字段：**

   - `Host: www.example.com`：请求的主机
   - `User-Agent: Mozilla/5.0 ...`：客户端信息
   - `Accept: text/html,...`：客户端接受的内容类型
   - `Accept-Language: en-US,en;q=0.5`：客户端接受的语言
   - `Accept-Encoding: gzip, deflate, br`：客户端接受的编码方式
   - `Connection: keep-alive`：保持连接
   - `Upgrade-Insecure-Requests: 1`：请求升级到 HTTPS

3. HTTP 响应报文示例

```python
HTTP/1.1 200 OK
Date: Sat, 12 Jun 2021 10:00:00 GMT
Server: Apache/2.4.41 (Ubuntu)
Last-Modified: Mon, 10 May 2021 14:30:00 GMT
Content-Length: 305
Content-Type: text/html; charset=UTF-8
Connection: Closed

<!DOCTYPE html>
<html>
<head>
    <title>Example Page</title>
</head>
<body>
    <h1>Welcome to the Example Page!</h1>
    <p>This is a sample HTML page.</p>
</body>
</html>
```

**解析:**

1. **状态行：**

   - ```
     HTTP/1.1 200 OK
     ```

     - `HTTP/1.1`：HTTP 版本
     - `200`：状态码，表示请求成功
     - `OK`：原因短语

2. **首部字段：**

   - `Date: Sat, 12 Jun 2021 10:00:00 GMT`：响应时间
   - `Server: Apache/2.4.41 (Ubuntu)`：服务器信息
   - `Last-Modified: Mon, 10 May 2021 14:30:00 GMT`：资源最后修改时间
   - `Content-Length: 305`：响应主体长度
   - `Content-Type: text/html; charset=UTF-8`：响应内容类型
   - `Connection: Closed`：关闭连接

3. **报文主体：**

   - 包含实际传输的数据内容，这里是一个简单的 HTML 页面。

### 用单台虚拟主机实现多个域名

1. HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。这是因为利用了虚拟主机（Virtual Host，又称虚拟服务器）的功
   能。即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假想已具有多台服务器。
2. 在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名的 Web 网站，因此在发送 HTTP 请求时，必须在 Host 首部内完整指定主机名或域名的 URI

### 通信数据转发程序 ：代理、网关、隧道

1. 代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时
   也接收服务器返回的响应并转发给客户端。

   使用代理服务器相当于有拦截器的功能：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。

   两种基准分类

   - 是否使用缓存

     代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

   - 是否会修改报文

     转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。

2. 网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。

   利用网关可以由 HTTP 请求转化为其他协议通信。

   利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。比如，网关可以连接数据库，使用SQL语句查询数据。另外，在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。

3. 隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

   隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析 HTTP 请求。

### 保存资源的缓存

1. 缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。

   利用缓存可避免多次从源服务器转发资源

2. 缓存的有效期限

   当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的“旧”资源了。

   客户端的缓存

   缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以Internet Explorer 程序为例，把客户端缓存称为临时网络文件。

## https

### 加密处理防止被窃听

1. 通信的加密

   - 通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密 HTTP 的通信内容。

   - 与 SSL组合使用的 HTTP 被称为 HTTPS（HTTPSecure，超文本传输安全协议）或 HTTP over SSL。

2. 内容的加密

   对 HTTP 协议传输的内容本身加密。即把HTTP 报文里所含的内容进行加密处理。前提是要求客户端和服务器同时具备加密和解密机制。

### HTTP 协议发送过来的请求都会响应，问题

1. 无法确定请求发送至目标的 Web 服务器是否是按真实意图返回响应的那台服务器。有可能是已伪装的 Web 服务器。
2. 无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端。
3. 无法确定正在通信的对方是否具备访问权限。因为某些Web 服务器上保存着重要的信息，只想发给特定用户通信的权限。
4. 无法判定请求是来自何方、出自谁手
5. 即使是无意义的请求也会照单全收。无法阻止海量请求下的 DoS 攻击（Denial of Service，拒绝服务攻击）。

### HTTP+ 加密 + 认证 + 完整性保护=HTTPS

1. 使用 HTTP 协议无法确定通信方，但如果使用 SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。
2. HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议
3. HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。

### HTTPS 比 HTTP 要慢 2 到 100 倍

SSL的慢分两种。一种是指通信慢。另一种是指由于大量消耗CPU 及内存等资源，导致处理速度变慢

### http和https的区别

1. HTTP 的 URL 以 HTTP:// 开头，而 HTTPS 的 URL 以 HTTPs:// 开头；
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
4. 传输效率上 HTTP 要高于 HTTPS ，因为 HTTPS 需要经过加密过程，过程相比于 HTTP 要繁琐一点，效率上低一些也很正常；
5. HTTP 无需证书，而 HTTPS 必需要认证证书；
6. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。



## 问题

1. 当输入www.google.com时，页面发生了哪些事情：

   - 域名解析域名解析检查顺序为：浏览器自身DNS缓存---》OS自身的DNS缓存--》读取host文件--》本地域名服务器--》权限域名服务器--》根域名服务器。如果有且没有过期，则结束本次域名解析。域名解析成功之后，进行后续操作
   - tcp3次握手建立连接
   - 建立连接后，发起http请求
   - 服务器端响应http请求，浏览器得到到http请求的内容；
   - 浏览器解析html代码，并请求html代码中的资源
   - 浏览器对页面进行渲染，展现在用户面前。

2. 说一下Http协议中302状态

   http协议中，返回状态码302表示重定向。这种情况下，服务器返回的头部信息中会包含一个 Location 字段，内容是重定向到的url

3. get与post请求区别？

   - 区别一：* get重点在从服务器上获取资源。* post重点在向服务器发送数据。
   - 区别二：* get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用"?"连接，多个请求数据间用"&"连接，如http://127.0.0.1/Test/login.action?name=admin&password=admin，这个过程用户是可见的。* post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的。
   - 区别三：* Get传输的数据量小，因为受URL长度限制，但效率较高。* Post可以传输大量数据，所以上传文件时只能用Post方式。
   - 区别四：* get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等。* post较get安全性较高。
   - 区别五：* get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。* post支持标准字符集，可以正确传递中文字符。

4. 在HTTP协议中，有两种类型的超时：

   1. 连接超时：这是在客户端等待建立连接的过程中发生的。如果在规定的时间内，服务器没有返回响应，客户端就会认为连接超时。这个超时时间可以在客户端的HTTP设置中进行配置。
   2. 请求超时：这是在客户端等待服务器响应的过程中发生的。如果在规定的时间内，服务器没有返回响应，客户端就会认为请求超时。这个超时时间也可以在客户端的HTTP设置中进行配置。

   

## 版本迭代

| 版本         | 发布年份 | 主要特点                                                     |
| ------------ | -------- | ------------------------------------------------------------ |
| **HTTP/0.9** | 1991     | - 只支持简单的GET请求<br>- 只传输纯文本内容<br>- 无HTTP头部和状态码<br>- 一次性连接 |
| **HTTP/1.0** | 1996     | - 支持GET、POST、HEAD请求方法<br>- 引入HTTP头部<br>- 支持状态码<br>- 一次性连接 |
| **HTTP/1.1** | 1997     | - 持久连接，连接复用 Connection: keep-alive<br>- 支持流水线<br>- 增强的缓存控制<br>- 分块传输编码<br>- 带宽优化和延迟处理 |
| **HTTP/2**   | 2015     | - 二进制分帧层<br>- 多路复用<br>- 头部压缩<br>- 服务器推送<br>- 改进的流量控制和错误处理 |
| **HTTP/3**   | 2022     | - 基于QUIC协议，运行在UDP之上<br>- 更低的延迟和更好的连接恢复能力<br>- 继承HTTP/2的特性<br>- 默认TLS 1.3加密 |